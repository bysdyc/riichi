// pages/game/game.js
const mahjong = require('../../utils/mahjong.js');
const yakuAnalyzer = require('../../utils/yaku-analyzer.js');

Page({
  data: {
    gameSettings: null,
    players: [],
    gameState: {
      wind: 'east',
      round: 1,
      honba: 0,
      riichiSticks: 0
    },
    currentDealerIndex: 0,
    roundHistory: [],
    isGameOver: false,
    
    // UI状态
    showWinDialog: false,
    showDrawDialog: false,
    showTileSelectorDialog: false,
    showMeldDialog: false,
    
    // 和牌输入模式: 'hand'(手牌输入), 'manual'(手动番符), 'multi'(多人和牌)
    inputMode: 'manual',
    
    // 和牌相关
    winnerIndex: null,
    loserIndex: null,
    isTsumo: true,
    han: 1,
    fu: 30,
    dora: 0,
    uraDora: 0,
    redDora: 0,
    pointsPreview: '',
    
    // 手牌输入相关
    handTiles: [],
    melds: [],
    winTile: null,
    isRiichi: false,
    isIppatsu: false,
    isDoubleRiichi: false,
    isHaitei: false,
    isHoutei: false,
    isRinshan: false,
    isChankan: false,
    analysisResult: null,
    analysisError: null,
    
    // 牌选择器
    tileSelectorTitle: '选择牌',
    tileSelectorMax: 13,
    tileSelectorInitial: [],
    tileSelectorType: 'hand', // 'hand', 'win', 'meld'
    
    // 副露相关
    meldTypes: [
      { id: 'shuntsu', name: '顺子' },
      { id: 'pon', name: '碰' },
      { id: 'minkan', name: '明杠' },
      { id: 'ankan', name: '暗杠' }
    ],
    selectedMeldType: 'shuntsu',
    meldTileCount: {
      'shuntsu': 3,
      'pon': 3,
      'minkan': 4,
      'ankan': 4
    },
    
    // 多人和牌相关
    multiLoserIndex: null,
    multiWinners: [false, false, false, false],
    multiHanFu: [
      { han: 1, fu: 30 },
      { han: 1, fu: 30 },
      { han: 1, fu: 30 },
      { han: 1, fu: 30 }
    ],
    
    // 流局相关
    tenpaiedPlayers: [false, false, false, false],
    
    // 最终排名
    finalRanking: [],
    
    // 场风文本
    windText: '東',
    
    // 牌显示映射
    tileDisplayMap: {
      '1m': '1万', '2m': '2万', '3m': '3万', '4m': '4万', '5m': '5万',
      '6m': '6万', '7m': '7万', '8m': '8万', '9m': '9万',
      '1p': '1筒', '2p': '2筒', '3p': '3筒', '4p': '4筒', '5p': '5筒',
      '6p': '6筒', '7p': '7筒', '8p': '8筒', '9p': '9筒',
      '1s': '1索', '2s': '2索', '3s': '3索', '4s': '4索', '5s': '5索',
      '6s': '6索', '7s': '7索', '8s': '8索', '9s': '9索',
      '1z': '东', '2z': '南', '3z': '西', '4z': '北',
      '5z': '白', '6z': '发', '7z': '中'
    }
  },

  onLoad() {
    this.loadGameState();
  },

  // 加载游戏状态
  loadGameState() {
    try {
      const savedState = wx.getStorageSync('riichi_game_state');
      if (savedState) {
        const { gameSettings, players, gameState, currentDealerIndex, roundHistory, isGameOver } = savedState;
        
        // 更新庄家标记
        players.forEach((p, i) => {
          p.isDealer = (i === currentDealerIndex);
        });
        
        this.setData({
          gameSettings,
          players,
          gameState,
          currentDealerIndex,
          roundHistory,
          isGameOver,
          windText: this.getWindText(gameState.wind)
        });

        if (isGameOver) {
          this.showGameOverDialog();
        }
      } else {
        wx.showModal({
          title: '错误',
          content: '未找到游戏数据，请返回首页重新开始',
          showCancel: false,
          success: () => {
            wx.navigateBack();
          }
        });
      }
    } catch (e) {
      console.error('加载游戏状态失败', e);
      wx.showToast({
        title: '加载失败',
        icon: 'error'
      });
    }
  },

  // 保存游戏状态
  saveGameState() {
    const state = {
      gameSettings: this.data.gameSettings,
      players: this.data.players,
      gameState: this.data.gameState,
      currentDealerIndex: this.data.currentDealerIndex,
      roundHistory: this.data.roundHistory,
      isGameOver: this.data.isGameOver
    };
    wx.setStorageSync('riichi_game_state', state);
  },

  // 获取场风文本
  getWindText(wind) {
    const windMap = {
      'east': '東',
      'south': '南',
      'west': '西',
      'north': '北'
    };
    return windMap[wind] || '東';
  },

  // 切换立直状态
  toggleRiichi(e) {
    const index = e.currentTarget.dataset.index;
    const players = this.data.players;
    const wasRiichi = players[index].isRiichi;
    
    players[index].isRiichi = !wasRiichi;
    
    // 更新立直棒数量
    const gameState = this.data.gameState;
    if (!wasRiichi) {
      gameState.riichiSticks += 1;
      players[index].score -= 1000; // 扣除立直棒
    } else {
      gameState.riichiSticks -= 1;
      players[index].score += 1000; // 退还立直棒
    }
    
    this.setData({
      players,
      gameState
    });
    
    this.saveGameState();
  },

  // 显示和牌对话框
  showWinDialog() {
    this.setData({
      showWinDialog: true,
      inputMode: 'manual',
      winnerIndex: null,
      loserIndex: null,
      isTsumo: true,
      han: 1,
      fu: 30,
      dora: 0,
      uraDora: 0,
      redDora: 0,
      pointsPreview: '',
      handTiles: [],
      melds: [],
      winTile: null,
      analysisResult: null,
      analysisError: null,
      multiLoserIndex: null,
      multiWinners: [false, false, false, false],
      multiHanFu: [
        { han: 1, fu: 30 },
        { han: 1, fu: 30 },
        { han: 1, fu: 30 },
        { han: 1, fu: 30 }
      ]
    });
  },

  // 切换输入模式
  switchInputMode(e) {
    const mode = e.currentTarget.dataset.mode;
    this.setData({
      inputMode: mode,
      analysisResult: null,
      analysisError: null
    });
  },

  // 获取牌的显示名称
  getTileDisplay(tile) {
    return this.data.tileDisplayMap[tile] || tile;
  },

  // 显示牌选择器
  showTileSelector(e) {
    const type = e.currentTarget.dataset.type;
    let title = '选择牌';
    let maxTiles = 13;
    
    if (type === 'hand') {
      title = '选择手牌';
      maxTiles = 13 - this.data.melds.length * 3;
    } else if (type === 'win') {
      title = '选择和牌';
      maxTiles = 1;
    }
    
    this.setData({
      showTileSelectorDialog: true,
      tileSelectorTitle: title,
      tileSelectorMax: maxTiles,
      tileSelectorType: type,
      tileSelectorInitial: type === 'hand' ? this.data.handTiles : []
    });
  },

  // 关闭牌选择器
  closeTileSelector() {
    this.setData({
      showTileSelectorDialog: false
    });
  },

  // 牌选择确认
  onTileSelected(e) {
    const tiles = e.detail.tiles;
    const type = this.data.tileSelectorType;
    
    if (type === 'hand') {
      this.setData({
        handTiles: tiles,
        showTileSelectorDialog: false
      });
    } else if (type === 'win') {
      this.setData({
        winTile: tiles[0],
        showTileSelectorDialog: false
      });
    }
  },

  // 牌选择变化
  onTileChange(e) {
    // 可以用于实时预览
  },

  // 清除和牌
  clearWinTile() {
    this.setData({
      winTile: null
    });
  },

  // 显示副露对话框
  showMeldDialog() {
    this.setData({
      showMeldDialog: true,
      selectedMeldType: 'shuntsu'
    });
  },

  // 关闭副露对话框
  closeMeldDialog() {
    this.setData({
      showMeldDialog: false
    });
  },

  // 选择副露类型
  selectMeldType(e) {
    const type = e.currentTarget.dataset.type;
    this.setData({
      selectedMeldType: type
    });
  },

  // 确认添加副露
  confirmMeld(e) {
    const tiles = e.detail.tiles;
    const type = this.data.selectedMeldType;
    
    // 验证副露
    if (type === 'shuntsu' || type === 'pon') {
      if (tiles.length !== 3) {
        wx.showToast({
          title: '需要3张牌',
          icon: 'none'
        });
        return;
      }
    } else if (type === 'minkan' || type === 'ankan') {
      if (tiles.length !== 4) {
        wx.showToast({
          title: '需要4张牌',
          icon: 'none'
        });
        return;
      }
    }
    
    const melds = [...this.data.melds];
    const typeNames = {
      'shuntsu': '顺子',
      'pon': '碰',
      'minkan': '明杠',
      'ankan': '暗杠'
    };
    
    melds.push({
      type: type,
      typeName: typeNames[type],
      tiles: tiles
    });
    
    this.setData({
      melds: melds,
      showMeldDialog: false
    });
  },

  // 删除副露
  removeMeld(e) {
    const index = e.currentTarget.dataset.index;
    const melds = [...this.data.melds];
    melds.splice(index, 1);
    this.setData({
      melds: melds
    });
  },

  // 状况役变化
  conditionChange(e) {
    const values = e.detail.value;
    this.setData({
      isRiichi: values.includes('riichi'),
      isIppatsu: values.includes('ippatsu'),
      isDoubleRiichi: values.includes('doubleRiichi'),
      isHaitei: values.includes('haitei'),
      isHoutei: values.includes('houtei'),
      isRinshan: values.includes('rinshan'),
      isChankan: values.includes('chankan')
    });
  },

  // 分析手牌
  analyzeHand() {
    const { handTiles, melds, winTile, isTsumo, isRiichi, isIppatsu, isDoubleRiichi,
            isHaitei, isHoutei, isRinshan, isChankan, winnerIndex, gameState } = this.data;
    
    if (!winTile) {
      this.setData({
        analysisError: '请选择和牌'
      });
      return;
    }
    
    // 构建14张牌（手牌+和牌）
    const allTiles = [...handTiles, winTile];
    
    if (allTiles.length + melds.length * 3 !== 14) {
      this.setData({
        analysisError: `牌数不正确：需要14张，当前${allTiles.length + melds.length * 3}张`
      });
      return;
    }
    
    // 获取玩家风和场风
    const playerWind = winnerIndex !== null ? this.data.players[winnerIndex].wind : '東';
    const windMap = { 'east': '東', 'south': '南', 'west': '西', 'north': '北' };
    const roundWind = windMap[gameState.wind];
    
    // 构建分析上下文
    const context = {
      isTsumo,
      isRiichi,
      isIppatsu,
      isDoubleRiichi,
      isTenhou: false,
      isChiihou: false,
      isRenhou: false,
      isHaitei,
      isHoutei,
      isRinshan,
      isChankan,
      isMenzen: melds.length === 0 || melds.every(m => m.type === 'ankan'),
      playerWind,
      roundWind,
      melds: melds
    };
    
    // 调用分析引擎
    const result = yakuAnalyzer.analyzeHand(allTiles, winTile, context);
    
    if (result.error) {
      this.setData({
        analysisError: result.error,
        analysisResult: null
      });
      return;
    }
    
    // 显示结果
    this.setData({
      analysisResult: {
        yaku: result.yaku.join('、'),
        han: result.han,
        fu: result.fu
      },
      analysisError: null,
      han: result.han,
      fu: result.fu
    });
    
    wx.showToast({
      title: '分析完成',
      icon: 'success'
    });
  },

  // 多人和牌 - 选择放铳者
  selectMultiLoser(e) {
    const index = e.currentTarget.dataset.index;
    
    // 如果之前选中的和牌者就是这个放铳者，取消选中
    const multiWinners = [...this.data.multiWinners];
    if (multiWinners[index]) {
      multiWinners[index] = false;
    }
    
    this.setData({
      multiLoserIndex: index,
      multiWinners: multiWinners
    });
  },

  // 多人和牌 - 切换和牌者
  toggleMultiWinner(e) {
    const index = e.currentTarget.dataset.index;
    const multiWinners = [...this.data.multiWinners];
    multiWinners[index] = !multiWinners[index];
    
    this.setData({
      multiWinners: multiWinners
    });
  },

  // 多人和牌 - 输入番数
  inputMultiHan(e) {
    const index = e.currentTarget.dataset.index;
    const han = parseInt(e.detail.value) || 1;
    const multiHanFu = [...this.data.multiHanFu];
    multiHanFu[index].han = Math.max(1, han);
    
    this.setData({
      multiHanFu: multiHanFu
    });
  },

  // 多人和牌 - 输入符数
  inputMultiFu(e) {
    const index = e.currentTarget.dataset.index;
    const fu = parseInt(e.detail.value) || 30;
    const multiHanFu = [...this.data.multiHanFu];
    multiHanFu[index].fu = Math.max(20, fu);
    
    this.setData({
      multiHanFu: multiHanFu
    });
  },

  // 关闭和牌对话框
  closeWinDialog() {
    this.setData({
      showWinDialog: false
    });
  },

  // 设置和牌类型
  setWinType(e) {
    const type = e.currentTarget.dataset.type;
    this.setData({
      isTsumo: type === 'tsumo',
      loserIndex: null
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 选择和牌者
  selectWinner(e) {
    const index = e.currentTarget.dataset.index;
    this.setData({
      winnerIndex: index
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 选择放铳者
  selectLoser(e) {
    const index = e.currentTarget.dataset.index;
    this.setData({
      loserIndex: index
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 输入番数
  inputHan(e) {
    const han = parseInt(e.detail.value) || 1;
    this.setData({
      han: Math.max(1, han)
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 输入符数
  inputFu(e) {
    const fu = parseInt(e.detail.value) || 30;
    this.setData({
      fu: Math.max(20, fu)
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 输入宝牌
  inputDora(e) {
    const dora = parseInt(e.detail.value) || 0;
    this.setData({
      dora: Math.max(0, dora)
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 输入里宝
  inputUraDora(e) {
    const uraDora = parseInt(e.detail.value) || 0;
    this.setData({
      uraDora: Math.max(0, uraDora)
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 输入红宝
  inputRedDora(e) {
    const redDora = parseInt(e.detail.value) || 0;
    this.setData({
      redDora: Math.max(0, redDora)
    }, () => {
      this.updatePointsPreview();
    });
  },

  // 更新点数预览
  updatePointsPreview() {
    const { winnerIndex, isTsumo, han, fu, dora, uraDora, redDora } = this.data;
    
    if (winnerIndex === null) {
      this.setData({ pointsPreview: '' });
      return;
    }

    const totalHan = han + dora + uraDora + redDora;
    const isDealer = (winnerIndex === this.data.currentDealerIndex);
    
    const payment = mahjong.calculatePoints(totalHan, fu, isDealer, isTsumo);
    
    let previewText = '';
    if (isTsumo) {
      previewText = `和牌者获得：${payment.winner}点`;
    } else {
      previewText = `和牌者获得：${payment.winner}点`;
    }
    
    this.setData({
      pointsPreview: previewText
    });
  },

  // 确认和牌
  confirmWin() {
    const { inputMode } = this.data;
    
    if (inputMode === 'multi') {
      this.confirmMultiWin();
      return;
    }
    
    const { winnerIndex, loserIndex, isTsumo, han, fu, dora, uraDora, redDora, players, gameState, currentDealerIndex } = this.data;
    
    if (winnerIndex === null) {
      wx.showToast({
        title: '请选择和牌者',
        icon: 'none'
      });
      return;
    }

    if (!isTsumo && loserIndex === null) {
      wx.showToast({
        title: '请选择放铳者',
        icon: 'none'
      });
      return;
    }

    const totalHan = han + dora + uraDora + redDora;
    const isDealer = (winnerIndex === currentDealerIndex);
    
    const payment = mahjong.calculatePoints(totalHan, fu, isDealer, isTsumo);
    
    // 更新分数
    const newPlayers = JSON.parse(JSON.stringify(players));
    
    if (isTsumo) {
      // 自摸
      for (let i = 0; i < 4; i++) {
        if (i === winnerIndex) {
          newPlayers[i].score += payment.winner;
        } else if (i === currentDealerIndex && i !== winnerIndex) {
          newPlayers[i].score += payment.dealer;
        } else {
          newPlayers[i].score += payment.nonDealer;
        }
      }
    } else {
      // 荣和
      newPlayers[winnerIndex].score += payment.winner;
      newPlayers[loserIndex].score += payment.loser;
    }

    // 和牌者收取立直棒
    newPlayers[winnerIndex].score += gameState.riichiSticks * 1000;
    newPlayers[winnerIndex].score += gameState.honba * 300;

    // 清除所有立直状态
    newPlayers.forEach(p => p.isRiichi = false);

    // 记录历史
    const roundHistory = [...this.data.roundHistory];
    roundHistory.push({
      type: 'win',
      wind: gameState.wind,
      round: gameState.round,
      honba: gameState.honba,
      winner: players[winnerIndex].name,
      loser: isTsumo ? '自摸' : players[loserIndex].name,
      han: totalHan,
      fu: fu,
      payment: isTsumo ? payment.winner : payment.winner
    });

    // 判断是否庄家胜利
    const dealerWon = (winnerIndex === currentDealerIndex);
    
    // 获取下一轮信息
    const nextRound = mahjong.getNextRound(gameState, dealerWon, currentDealerIndex);
    
    // 更新庄家标记
    newPlayers.forEach((p, i) => {
      p.isDealer = (i === nextRound.newDealerIndex);
    });

    // 检查游戏是否结束
    const gameEnd = mahjong.checkGameEnd(
      this.data.gameSettings,
      { wind: nextRound.wind, round: nextRound.round, honba: nextRound.honba },
      newPlayers,
      nextRound.newDealerIndex
    );

    this.setData({
      players: newPlayers,
      gameState: {
        wind: nextRound.wind,
        round: nextRound.round,
        honba: nextRound.honba,
        riichiSticks: 0
      },
      currentDealerIndex: nextRound.newDealerIndex,
      roundHistory,
      windText: this.getWindText(nextRound.wind),
      showWinDialog: false,
      isGameOver: gameEnd.ended
    });

    this.saveGameState();

    if (gameEnd.ended) {
      this.showGameOverDialog();
    } else {
      wx.showToast({
        title: '已记录',
        icon: 'success'
      });
    }
  },

  // 显示流局对话框
  showDrawDialog() {
    this.setData({
      showDrawDialog: true,
      tenpaiedPlayers: [false, false, false, false]
    });
  },

  // 关闭流局对话框
  closeDrawDialog() {
    this.setData({
      showDrawDialog: false
    });
  },

  // 切换听牌状态
  toggleTenpai(e) {
    const index = e.currentTarget.dataset.index;
    const tenpaiedPlayers = this.data.tenpaiedPlayers;
    tenpaiedPlayers[index] = !tenpaiedPlayers[index];
    this.setData({
      tenpaiedPlayers
    });
  },

  // 确认流局
  confirmDraw() {
    const { tenpaiedPlayers, players, gameState, currentDealerIndex } = this.data;
    
    // 计算流局分数变化
    const payment = mahjong.calculateDrawPayment(tenpaiedPlayers);
    
    // 更新分数
    const newPlayers = JSON.parse(JSON.stringify(players));
    for (let i = 0; i < 4; i++) {
      newPlayers[i].score += payment[i];
    }

    // 清除所有立直状态（流局时立直棒不退还，留到下一局）
    newPlayers.forEach(p => p.isRiichi = false);

    // 记录历史
    const roundHistory = [...this.data.roundHistory];
    roundHistory.push({
      type: 'draw',
      wind: gameState.wind,
      round: gameState.round,
      honba: gameState.honba,
      tenpai: tenpaiedPlayers.map((t, i) => t ? players[i].name : null).filter(Boolean).join('、') || '无人听牌'
    });

    // 判断庄家是否听牌（听牌则连庄）
    const dealerTenpai = tenpaiedPlayers[currentDealerIndex];
    
    // 获取下一轮信息
    const nextRound = mahjong.getNextRound(gameState, dealerTenpai, currentDealerIndex);
    
    // 更新庄家标记
    newPlayers.forEach((p, i) => {
      p.isDealer = (i === nextRound.newDealerIndex);
    });

    // 检查游戏是否结束
    const gameEnd = mahjong.checkGameEnd(
      this.data.gameSettings,
      { wind: nextRound.wind, round: nextRound.round, honba: nextRound.honba },
      newPlayers,
      nextRound.newDealerIndex
    );

    this.setData({
      players: newPlayers,
      gameState: {
        wind: nextRound.wind,
        round: nextRound.round,
        honba: nextRound.honba,
        riichiSticks: gameState.riichiSticks // 流局保留立直棒
      },
      currentDealerIndex: nextRound.newDealerIndex,
      roundHistory,
      windText: this.getWindText(nextRound.wind),
      showDrawDialog: false,
      isGameOver: gameEnd.ended
    });

    this.saveGameState();

    if (gameEnd.ended) {
      this.showGameOverDialog();
    } else {
      wx.showToast({
        title: '流局已记录',
        icon: 'success'
      });
    }
  },

  // 确认多人和牌
  confirmMultiWin() {
    const { multiLoserIndex, multiWinners, multiHanFu, players, gameState, currentDealerIndex } = this.data;
    
    if (multiLoserIndex === null) {
      wx.showToast({
        title: '请选择放铳者',
        icon: 'none'
      });
      return;
    }
    
    const winnerCount = multiWinners.filter(w => w).length;
    if (winnerCount < 2) {
      wx.showToast({
        title: '至少需要2位和牌者',
        icon: 'none'
      });
      return;
    }
    
    if (winnerCount > 3) {
      wx.showToast({
        title: '最多3位和牌者',
        icon: 'none'
      });
      return;
    }
    
    // 计算每位和牌者的得分
    const newPlayers = JSON.parse(JSON.stringify(players));
    let totalPayment = 0;
    const winnerDetails = [];
    
    for (let i = 0; i < 4; i++) {
      if (multiWinners[i]) {
        const { han, fu } = multiHanFu[i];
        const isDealer = (i === currentDealerIndex);
        
        // 三家和都是荣和
        const payment = mahjong.calculatePoints(han, fu, isDealer, false);
        
        newPlayers[i].score += payment.winner;
        totalPayment += payment.winner;
        
        winnerDetails.push({
          name: players[i].name,
          wind: players[i].wind,
          isDealer: isDealer,
          han: han,
          fu: fu,
          score: payment.winner
        });
      }
    }
    
    // 放铳者支付所有点数
    newPlayers[multiLoserIndex].score -= totalPayment;
    
    // 立直棒分配（平均分给所有和牌者）
    const riichiBonus = Math.floor(gameState.riichiSticks * 1000 / winnerCount);
    for (let i = 0; i < 4; i++) {
      if (multiWinners[i]) {
        newPlayers[i].score += riichiBonus;
      }
    }
    
    // 本场费也平均分配
    const honbaBonus = Math.floor(gameState.honba * 300 / winnerCount);
    for (let i = 0; i < 4; i++) {
      if (multiWinners[i]) {
        newPlayers[i].score += honbaBonus;
      }
    }
    
    // 清除所有立直状态
    newPlayers.forEach(p => p.isRiichi = false);
    
    // 记录历史
    const roundHistory = [...this.data.roundHistory];
    roundHistory.push({
      type: 'win',
      isMultiWin: true,
      multiWinCount: winnerCount,
      wind: gameState.wind,
      round: gameState.round,
      honba: gameState.honba,
      winner: winnerDetails.map(w => w.name).join('、'),
      loser: players[multiLoserIndex].name,
      winnersDetails: winnerDetails,
      score: totalPayment,
      riichiBonus: riichiBonus * winnerCount
    });
    
    // 判断是否庄家和牌（如果有庄家和牌则连庄）
    const dealerWon = multiWinners[currentDealerIndex];
    
    // 获取下一轮信息
    const nextRound = mahjong.getNextRound(gameState, dealerWon, currentDealerIndex);
    
    // 更新庄家标记
    newPlayers.forEach((p, i) => {
      p.isDealer = (i === nextRound.newDealerIndex);
    });
    
    // 检查游戏是否结束
    const gameEnd = mahjong.checkGameEnd(
      this.data.gameSettings,
      { wind: nextRound.wind, round: nextRound.round, honba: nextRound.honba },
      newPlayers,
      nextRound.newDealerIndex
    );
    
    this.setData({
      players: newPlayers,
      gameState: {
        wind: nextRound.wind,
        round: nextRound.round,
        honba: nextRound.honba,
        riichiSticks: 0
      },
      currentDealerIndex: nextRound.newDealerIndex,
      roundHistory,
      windText: this.getWindText(nextRound.wind),
      showWinDialog: false,
      isGameOver: gameEnd.ended
    });
    
    this.saveGameState();
    
    if (gameEnd.ended) {
      this.showGameOverDialog();
    } else {
      wx.showToast({
        title: `三家和已记录 (${winnerCount}家)`,
        icon: 'success'
      });
    }
  },

  // 显示游戏结束对话框
  showGameOverDialog() {
    const ranking = [...this.data.players].sort((a, b) => b.score - a.score);
    this.setData({
      finalRanking: ranking,
      isGameOver: true
    });
  },

  // 返回首页
  backToHome() {
    wx.navigateBack();
  },

  // 显示历史记录
  showHistory() {
    wx.showModal({
      title: '历史记录',
      content: '历史记录功能开发中...',
      showCancel: false
    });
  },

  // 显示设置
  showSettings() {
    wx.showModal({
      title: '设置',
      content: '设置功能开发中...',
      showCancel: false
    });
  },

  // 阻止事件冒泡
  stopPropagation() {
    // 空函数，用于阻止对话框内容点击时关闭对话框
  }
});
