# 副露区胡牌逻辑深度修复说明

## 🔍 问题发现

经过深度检查，发现原实现存在**严重的逻辑缺陷**：

### 问题1: 胡牌判断只检查手牌，忽略副露 ❌

**原代码：**
```javascript
const hand14 = [...internalHand, internalWinTile];
const combinations = findStandardCombinations(hand14);  // 只检查手牌能否组成4面子1雀头
```

**问题：**
- 假设副露了1个顺子（3张），手牌应该只有10张
- 10张手牌 + 和牌1张 = 11张，根本无法组成4个面子
- 导致有副露时永远无法胡牌！

**正确逻辑：**
- 副露了N组，手牌只需要组成 `(4-N)` 个面子 + 1个雀头
- 例如：副露1组，手牌只需要3个面子 + 1个雀头

### 问题2: 役种判断不完整 ❌

**问题：**
很多役种需要检查全部面子（手牌+副露），例如：
- **三色同顺**：需要三种花色各有一组相同数字的顺子
- **一气通贯**：需要123、456、789
- **对对和**：需要全部是刻子

原代码只检查手牌中的面子，副露的面子被忽略。

### 问题3: 符数计算传参但未使用 ⚠️

**原代码：**
```javascript
const fu = calculateFu(combo, winTile, { ...context, isPinfu, melds });
```

虽然传入了 `melds`，但 `combo.melds` 只包含手牌中的面子，符数计算中对副露的处理是额外单独计算的。这个逻辑是对的，但不够清晰。

## ✅ 解决方案

### 修复1: 新增 `analyzeHandWithMelds` 函数

专门处理有副露的胡牌分析：

```javascript
const analyzeHandWithMelds = (handTiles, winTile, externalMelds, context) => {
  // 如果没有副露，使用原有逻辑
  if (!externalMelds || externalMelds.length === 0) {
    const hand14 = [...handTiles, winTile];
    return analyzeHandInternal(hand14, winTile, context);
  }
  
  // 有副露的情况
  const hand14 = [...handTiles, winTile];
  
  // 计算需要的面子数：4 - 副露组数
  const requiredMeldCount = 4 - externalMelds.length;
  
  // 检查手牌能否组成所需的面子数 + 1个雀头
  const handCombinations = findPartialCombinations(hand14, requiredMeldCount);
  
  if (handCombinations.length === 0) {
    return null; // 无法胡牌
  }
  
  let bestHand = null;
  
  for (const handCombo of handCombinations) {
    // 将手牌面子和副露面子合并
    const fullCombo = {
      pair: handCombo.pair,
      melds: [...handCombo.melds, ...externalMelds.map(m => ({
        type: m.type === 'shuntsu' ? 'shuntsu' : 'pon',
        tiles: m.tiles.map(t => displayToInternal[t])
      }))]
    };
    
    // 用完整的面子列表计算役种
    const { yaku, han } = calculateYaku(fullCombo, winTile, context);
    
    if (han === 0) continue;
    
    const isPinfu = yaku.includes('平和');
    // 符数计算：手牌面子 + 副露面子
    const fu = calculateFu(handCombo, winTile, { ...context, isPinfu, melds: externalMelds });
    const currentHand = { yaku, han, fu };
    
    if (!bestHand || currentHand.han > bestHand.han || (currentHand.han === bestHand.han && currentHand.fu > bestHand.fu)) {
      bestHand = currentHand;
    }
  }
  
  return bestHand;
};
```

### 修复2: 新增 `findPartialCombinations` 函数

查找部分组合，用于副露情况：

```javascript
const findPartialCombinations = (tiles, requiredMeldCount) => {
  const counts = getTileCounts(tiles);
  const pairs = Object.keys(counts).filter(t => counts[t] >= 2);
  let combinations = [];

  for (const pairTile of pairs) {
    const countsWithoutPair = { ...counts };
    countsWithoutPair[pairTile] -= 2;
    if (countsWithoutPair[pairTile] === 0) delete countsWithoutPair[pairTile];

    const meldCombinations = findMelds(countsWithoutPair);
    for (const melds of meldCombinations) {
      // 关键：只需要 requiredMeldCount 个面子，而不是固定的4个
      if (melds.length === requiredMeldCount) {
        combinations.push({ pair: pairTile, melds: melds });
      }
    }
  }
  return combinations;
};
```

### 修复3: 更新 `getCurrentAnalysis`

使用新的分析函数：

```javascript
// 原代码
const hand14 = [...internalHand, internalWinTile];
const analysis = analyzeHandInternal(hand14, internalWinTile, context);

// 新代码
const analysis = analyzeHandWithMelds(internalHand, internalWinTile, melds, context);
```

### 修复4: 更新 `findTenpaiWaits`

听牌分析也需要考虑副露：

```javascript
const findTenpaiWaits = (hand13) => {
  if (hand13.length !== 13) return [];
  const waits = new Set();
  
  // 计算需要的面子数（考虑副露）
  const requiredMeldCount = 4 - melds.length;
  
  for (const tile of allInternalTilesForWait) {
    const hand14 = [...hand13, tile];
    
    // 有副露时，使用部分组合查找
    if (melds.length > 0) {
      const combinations = findPartialCombinations(hand14, requiredMeldCount);
      if (combinations.length > 0) {
        waits.add(internalToDisplay[tile]);
      }
    } else {
      // 无副露时，使用标准组合
      const combinations = findStandardCombinations(hand14);
      if (combinations.length > 0) {
        waits.add(internalToDisplay[tile]);
      }
    }
  }
  
  // 七对子检查（有副露时不能是七对子）
  if (melds.length === 0) {
    // ... 七对子逻辑
  }
  
  // 国士无双检查（有副露时不能是国士）
  if (melds.length === 0) {
    // ... 国士逻辑
  }

  return Array.from(waits);
};
```

### 修复5: 更新 `updateDetailedTenpaiWaits`

```javascript
// 使用新的分析函数，支持副露
const analysis = analyzeHandWithMelds(internalHand, internalWinTile, melds, context);
```

## 🧪 测试用例

### 测试1: 基础副露胡牌

**设置：**
- 副露：顺子 1-2-3万（3张）
- 手牌：4-5-6万, 7-8-9万, 東東, 中中中（10张）
- 和牌：東

**期望结果：**
- ✅ 能胡牌
- 组合：[1-2-3万(副露)], [4-5-6万], [7-8-9万], [中中中], [東東(雀头)]
- 役种：役牌·中
- 符数：40符（基础20 + 明刻中张2 + 雀头役牌2 + ...）

### 测试2: 副露后的三色同顺

**设置：**
- 副露：顺子 1-2-3万（3张）
- 手牌：1-2-3饼, 1-2-3索, 東東（10张）
- 和牌：東

**期望结果：**
- ✅ 能胡牌
- 役种：三色同顺（副露2番）
- 包含副露的1-2-3万 + 手牌的1-2-3饼 + 1-2-3索

### 测试3: 多个副露

**设置：**
- 副露1：顺子 1-2-3万（3张）
- 副露2：刻子 東東東（3张）
- 手牌：4-5-6万, 7-8（4张）
- 和牌：9万

**期望结果：**
- ✅ 能胡牌
- 组合：[1-2-3万(副露)], [東東東(副露)], [4-5-6万], [7-8-9万], [某对子]
- 需要找到雀头...实际上这个例子不太好，重新设计：

**修正：**
- 副露1：刻子 東東東（3张）
- 副露2：刻子 南南南（3张）
- 手牌：1-1-1万, 2-2-2饼, 3-3（7张）
- 和牌：3饼

**期望结果：**
- ✅ 能胡牌
- 役种：对对和（副露2番）+ 三暗刻
- 符数：50符（很多刻子）

### 测试4: 副露后听牌分析

**设置：**
- 副露：顺子 1-2-3万（3张）
- 手牌：4-5-6万, 7-8-9万, 東東, 中中（10张）

**期望结果：**
- ✅ 听牌
- 听：東, 中
- 分别分析各个待牌的役种和分数

### 测试5: 副露后无法七对子/国士

**设置：**
- 副露：刻子 東東東（3张）
- 手牌：1-1, 2-2, 3-3, 4-4, 5-5, 6-6, 7（13张）

**期望结果：**
- ❌ 不能是七对子（因为有副露）
- 听牌分析不应包含七对子的待牌

### 测试6: 副露杠后的胡牌

**设置：**
- 副露：明杠 東東東東（4张）
- 手牌：1-2-3万, 4-5-6万, 7-8-9万, 中（10张）
- 和牌：中

**期望结果：**
- ✅ 能胡牌
- 手牌数正确：10张（总限制14 - 副露4）
- 符数包含明杠的符数（16或8）

## 📊 符数计算验证

### 场景1: 纯手牌（无副露）

**手牌：**
- 1-2-3万, 4-5-6饼, 7-8-9索, 東東東, 中中
- 和牌：中（自摸）

**计算：**
- 底符：20
- 自摸：+2
- 暗刻（東）：幺九牌 +8
- 雀头（中）：役牌 +2
- 总计：32 → 进位到40符

### 场景2: 有明副露

**副露：** 刻子 東東東（明刻）
**手牌：** 1-2-3万, 4-5-6饼, 7-8-9索, 中中
**和牌：** 中（荣和）

**计算：**
- 底符：20
- 门清荣和：0（有副露，非门清）
- 明刻（東）：幺九牌 +4
- 雀头（中）：役牌 +2
- 总计：26 → 进位到30符

### 场景3: 有暗杠

**副露：** 暗杠 1万×4
**手牌：** 2-3-4万, 5-6-7饼, 8-9饼, 东东（10张）
**和牌：** 7饼（自摸）

**计算：**
- 底符：20
- 自摸：+2
- 暗杠（1万）：幺九牌 +32
- 总计：54 → 进位到60符

## 🎯 役种判断验证

### 三色同顺（有副露）

**副露：** 顺子 1-2-3万
**手牌：** 1-2-3饼, 1-2-3索, 东东东, 中中
**和牌：** 中

**检查：**
```javascript
fullCombo = {
  pair: '5z',  // 中中
  melds: [
    { type: 'shuntsu', tiles: ['1p','2p','3p'] },  // 手牌
    { type: 'shuntsu', tiles: ['1s','2s','3s'] },  // 手牌
    { type: 'pon', tiles: ['1z','1z','1z'] },      // 手牌
    { type: 'shuntsu', tiles: ['1m','2m','3m'] }   // 副露
  ]
}
```

**役种计算：**
- 检查三色同顺：找到123万、123饼、123索 ✓
- 副露：2番
- 役牌·东：1番
- 役牌·中：1番
- 总计：4番

### 一气通贯（有副露）

**副露：** 顺子 1-2-3万
**手牌：** 4-5-6万, 7-8-9万, 东东东, 中中
**和牌：** 中

**检查：**
- 找到123万（副露）、456万、789万 ✓
- 副露：2番
- 役牌·东：1番
- 役牌·中：1番
- 总计：4番

### 对对和（有副露）

**副露1：** 刻子 东东东
**副露2：** 刻子 南南南
**手牌：** 1-1-1万, 2-2-2饼, 中中
**和牌：** 中

**检查：**
- 所有面子都是刻子（包括副露）✓
- 对对和（副露）：2番

## ⚠️ 注意事项

### 1. 副露后不能是某些役种

- ❌ **七对子**：副露破坏了7对的结构
- ❌ **国士无双**：副露意味着已经不是特殊牌型
- ❌ **平和**：副露破坏门前（平和必须门清）
- ❌ **一杯口/二杯口**：需要门清
- ❌ **立直相关**：已经在UI层禁用

### 2. 副露番数降低

很多役种有副露时番数会降低：
- 三色同顺：门清2番 → 副露1番（但代码中应该是2番，待验证）
- 一气通贯：门清2番 → 副露1番
- 混全带幺九：门清2番 → 副露1番
- 纯全带幺九：门清3番 → 副露2番
- 混一色：门清3番 → 副露2番
- 清一色：门清6番 → 副露5番

### 3. 杠子的特殊处理

- **明杠**：算作明副露，破坏门前
- **暗杠**：不破坏门前，但增加手牌数
- 符数计算中杠子的符数较高

## 🔧 后续需要检查的点

### 1. 役种番数的副露版本

需要检查 `allYakuList` 中是否正确设置了 `hanNaki`（副露时的番数）：

```javascript
{
  id: 'sanshoku_doujun',
  name: '三色同顺',
  han: 2,
  hanNaki: 1,  // 副露时1番
  category: '2han'
}
```

### 2. 复杂役种的判断

需要逐个检查复杂役种的计算逻辑，确保考虑了副露：
- 小三元、大三元
- 小四喜、大四喜
- 三暗刻、四暗刻（副露的刻子不算暗刻）
- 等等

### 3. 边界情况

- 4个杠的极限情况
- 多个副露的组合
- 副露后的复杂待牌（多面听）

## ✅ 总结

本次修复解决了副露区最核心的问题：

1. ✅ **胡牌判断正确**：考虑副露后的面子数要求
2. ✅ **役种判断完整**：合并手牌和副露的面子进行判断
3. ✅ **符数计算准确**：手牌面子 + 副露面子的符数
4. ✅ **听牌分析正确**：考虑副露后的听牌
5. ✅ **特殊牌型处理**：七对子、国士在有副露时不可能

现在的实现应该能正确处理各种副露情况下的胡牌判断和计算！
