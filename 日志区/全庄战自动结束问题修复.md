# 全庄战自动结束问题修复 🔧

## 修复日期: 2025年10月28日

---

## 🐛 问题描述

**症状**: 全庄战(四场战)打到北4局结束后,游戏不会自动结束,会继续进行。

**影响**: 
- 全庄战无法正常结束
- 玩家需要手动点击"重置"才能结束游戏
- 历史记录会记录超出范围的局数

---

## 🔍 问题分析

### 原有代码 (❌ 错误)

```javascript
const checkGameOver = (newPlayers, nextRoundState) => {
  const { wind, round } = nextRoundState;
  
  // 全庄战结束判断
  if (gameSettings.type === 'yonchan' && wind === 'north' && round > 4) {
    isGameOver = true;
    return true;
  }
}
```

### 问题根源

**逻辑错误**: 条件 `wind === 'north' && round > 4` 永远不会同时满足!

**原因分析**:

1. **风位切换时机**: 
   ```javascript
   // goToNextRound 函数中
   if (newRound > 4) {
     newRound = 1;
     const windOrder = ['east', 'south', 'west', 'north'];
     const currentWindIndex = windOrder.indexOf(gameState.wind);
     if (currentWindIndex < windOrder.length - 1) {
       newWind = windOrder[currentWindIndex + 1]; // 切换到下一风位
     }
   }
   ```

2. **执行流程**:
   ```
   北4局结束 → 非连庄
   ↓
   newRound = 5 (round > 4)
   ↓
   newRound = 1, newWind = '???' (下一风位)
   ↓
   但是 windOrder 只有 4 个元素: ['east', 'south', 'west', 'north']
   currentWindIndex = 3 (north的索引)
   currentWindIndex < windOrder.length - 1 → 3 < 3 → false
   ↓
   newWind 不变,仍然是 'north'
   ```

3. **检查时机**:
   ```
   checkGameOver(players, nextState)
   此时: wind = 'north', round = 1 (已经重置为1)
   条件: wind === 'north' && round > 4
   结果: 'north' === 'north' ✅ && 1 > 4 ❌ → false
   游戏继续!
   ```

### 实际情况

- **北1局**: wind='north', round=1 → 条件不满足(1 ≤ 4)
- **北2局**: wind='north', round=2 → 条件不满足(2 ≤ 4)
- **北3局**: wind='north', round=3 → 条件不满足(3 ≤ 4)
- **北4局**: wind='north', round=4 → 条件不满足(4 ≤ 4)
- **北4局结束**: 
  - `newRound = 5` (round > 4)
  - `newRound = 1, newWind = 'north'` (因为已经是最后一个风位)
  - 检查: `wind='north' && round=1` → ❌ 不满足
- **继续北1局(第二轮)**: 游戏没有结束! 🐛

---

## ✅ 修复方案

### 核心问题

**问题**: `goToNextRound` 函数中,在检查游戏是否结束之前,就已经将 `newRound` 重置为 1 了!

```javascript
// ❌ 原有代码
if (newRound > 4) {
  newRound = 1;  // ← 先重置
  // ... 切换风位
}

const nextState = { wind: newWind, round: newRound, ... };
checkGameOver(players, nextState);  // ← 此时 round 已经是 1 了!
```

**结果**: `checkGameOver` 检查时,`round = 1`,条件 `round > 4` 永远不满足!

### 解决方案

**在重置 round 之前先检查游戏是否结束**:

```javascript
// ✅ 修复后的代码
if (newRound > 4) {
  // 1. 先创建未重置的状态
  const nextStateBeforeReset = { 
    ...gameState, 
    wind: newWind, 
    round: newRound,  // ← 此时 round = 5
    honba: newHonba, 
    riichiSticks: newRiichiSticks 
  };
  
  // 2. 先检查游戏是否结束
  if (checkGameOver(players, nextStateBeforeReset)) {
    gameState = nextStateBeforeReset;
    return;  // ← 游戏结束,直接返回
  }
  
  // 3. 游戏未结束,才重置 round 并切换风位
  newRound = 1;
  const windOrder = ['east', 'south', 'west', 'north'];
  const currentWindIndex = windOrder.indexOf(gameState.wind);
  if (currentWindIndex < windOrder.length - 1) {
    newWind = windOrder[currentWindIndex + 1];
  }
}
```

### 执行流程

#### 北4局结束(非连庄) - 全庄战应该结束

```
1. newRound = gameState.round + 1 = 4 + 1 = 5
2. newRound > 4 ✅
3. 创建 nextStateBeforeReset: { wind: 'north', round: 5, ... }
4. checkGameOver(players, nextStateBeforeReset)
   → wind === 'north' ✅ && round > 4 ✅
   → isGameOver = true
5. gameState = nextStateBeforeReset
6. return (退出函数)
7. 游戏结束! ✅
```

#### 西4局结束(非连庄) - 半庄战应该继续到北场

```
1. newRound = gameState.round + 1 = 4 + 1 = 5
2. newRound > 4 ✅
3. 创建 nextStateBeforeReset: { wind: 'west', round: 5, ... }
4. checkGameOver(players, nextStateBeforeReset)
   → gameSettings.type === 'hanchan' ✅ && wind === 'west' ✅
   → isGameOver = true
5. gameState = nextStateBeforeReset
6. return
7. 游戏结束! ✅
```

#### 南4局结束(非连庄) - 全庄战应该继续到西场

```
1. newRound = gameState.round + 1 = 4 + 1 = 5
2. newRound > 4 ✅
3. 创建 nextStateBeforeReset: { wind: 'south', round: 5, ... }
4. checkGameOver(players, nextStateBeforeReset)
   → gameSettings.type === 'yonchan' ✅
   → wind === 'north' ❌ (wind 是 'south')
   → return false
5. checkGameOver 返回 false,继续执行
6. newRound = 1 (重置)
7. newWind = 'west' (切换到西场)
8. nextState = { wind: 'west', round: 1, ... }
9. 游戏继续! ✅
```

---

## 🔧 完整修复代码

### checkGameOver 函数 (优化注释)

```javascript
const checkGameOver = (newPlayers, nextRoundState) => {
  if (isGameOver) return true;

  if (gameSettings.tobu && newPlayers.some(p => p.score < 0)) {
    isGameOver = true;
    return true;
  }
  
  const { wind, round } = nextRoundState;
  
  // 东风战: 东场结束(进入南场)时结束
  if (gameSettings.type === 'tonpuu' && wind === 'south') {
    isGameOver = true;
    return true;
  }
  
  // 半庄战: 南场结束(进入西场)时结束
  if (gameSettings.type === 'hanchan' && wind === 'west') {
    isGameOver = true;
    return true;
  }
  
  // 全庄战: 北场第4局结束后结束
  if (gameSettings.type === 'yonchan') {
    // 北场结束: round > 4 意味着北4局已结束,准备切换风位
    if (wind === 'north' && round > 4) {
      isGameOver = true;
      return true;
    }
    // 保险: 如果已经到了北场之后的风位(理论上不应该)
    const windOrder = ['east', 'south', 'west', 'north'];
    const windIndex = windOrder.indexOf(wind);
    if (windIndex > 3) {
      isGameOver = true;
      return true;
    }
  }
  
  return false;
};
```

### goToNextRound 函数 (关键修复)

```javascript
const goToNextRound = (dealerContinuation) => {
  let newWind = gameState.wind;
  let newRound = gameState.round;
  let newHonba = gameState.honba;
  let newDealerIndex = currentDealerIndex;
  let newRiichiSticks = gameState.riichiSticks;

  if (dealerContinuation) {
    // 连庄：本场数+1，庄家和局数不变
    newHonba += 1;
  } else {
    // 非连庄：本场数归零，进入下一局
    newHonba = 0;
    newRound += 1;
    newDealerIndex = (currentDealerIndex + 1) % 4;
    
    // 完成4局后，进入下一风局
    if (newRound > 4) {
      // ⚡ 关键修复: 先检查游戏是否结束 (在重置 round 之前)
      const nextStateBeforeReset = { 
        ...gameState, 
        wind: newWind, 
        round: newRound, 
        honba: newHonba, 
        riichiSticks: newRiichiSticks 
      };
      
      // 如果游戏结束,直接应用状态并返回
      if (checkGameOver(players, nextStateBeforeReset)) {
        gameState = nextStateBeforeReset;
        return;
      }
      
      // 游戏未结束,继续切换风位
      newRound = 1;
      const windOrder = ['east', 'south', 'west', 'north'];
      const currentWindIndex = windOrder.indexOf(gameState.wind);
      if (currentWindIndex < windOrder.length - 1) {
        newWind = windOrder[currentWindIndex + 1];
      }
    }
  }
  
  const nextState = { ...gameState, wind: newWind, round: newRound, honba: newHonba, riichiSticks: newRiichiSticks };
  
  if (!checkGameOver(players, nextState)) {
    gameState = nextState;
    currentDealerIndex = newDealerIndex;
    
    const newPlayerWinds = ['东', '南', '西', '北'];
    const rotatedPlayers = [...players];
    for (let i = 0; i < 4; i++) {
      rotatedPlayers[i].wind = newPlayerWinds[(i - newDealerIndex + 4) % 4];
    }
    players = rotatedPlayers;
  }
};
```

---

## 🧪 验证测试

### 测试场景1: 全庄战正常流程

```
东1局 → 东2局 → 东3局 → 东4局
→ 南1局 → 南2局 → 南3局 → 南4局
→ 西1局 → 西2局 → 西3局 → 西4局
→ 北1局 → 北2局 → 北3局 → 北4局
→ 北4局结束(非连庄)
```

**预期结果**: 
- `goToNextRound(false)` 被调用
- `newRound = 5, wind = 'north'`
- `checkGameOver(players, {wind: 'north', round: 5, ...})`
- 条件满足: `'north' === 'north' && 5 > 4` ✅
- 游戏结束,显示最终结算界面

### 测试场景2: 北4局连庄

```
北4局 → 庄家和牌 → 连庄
→ 北4局 1本场
```

**预期结果**:
- `goToNextRound(true)` 被调用
- `newRound = 4, newHonba = 1, wind = 'north'`
- `checkGameOver(players, {wind: 'north', round: 4, ...})`
- 条件不满足: `'north' === 'north' && 4 > 4` ❌
- 游戏继续,进入北4局1本场 ✅

### 测试场景3: 北4局多次连庄后非连庄

```
北4局 → 连庄 → 北4局1本场 → 连庄 → 北4局2本场
→ 闲家和牌 → 非连庄
```

**预期结果**:
- `goToNextRound(false)` 被调用
- `newRound = 5, wind = 'north'`
- 条件满足: `'north' === 'north' && 5 > 4` ✅
- 游戏结束 ✅

---

## 📊 三种战型对比

| 战型 | 结束条件 | 说明 |
|------|---------|------|
| 东风战 | `wind === 'south'` | 东场(4局)结束后,进入南场时自动结束 |
| 半庄战 | `wind === 'west'` | 南场(8局)结束后,进入西场时自动结束 |
| 全庄战 | `wind === 'north' && round > 4` | 北场(16局)结束后,round变为5时结束 |

### 为什么全庄战的判断不同?

**原因**: 风位切换逻辑的限制

```javascript
const windOrder = ['east', 'south', 'west', 'north'];
const currentWindIndex = windOrder.indexOf(gameState.wind);
if (currentWindIndex < windOrder.length - 1) {
  newWind = windOrder[currentWindIndex + 1];
}
```

- **东场结束**: currentWindIndex = 0 → 切换到 south ✅
- **南场结束**: currentWindIndex = 1 → 切换到 west ✅
- **西场结束**: currentWindIndex = 2 → 切换到 north ✅
- **北场结束**: currentWindIndex = 3 → 3 < 3 ❌ → wind 不变

所以:
- 东风战和半庄战: 可以通过 **wind 的变化** 来判断
- 全庄战: 必须通过 **wind='north' 且 round > 4** 来判断

---

## 🎯 修复总结

### 问题本质
**调用时机错误**: `goToNextRound` 函数在检查游戏是否结束之前,就已经将 `newRound` 从 5 重置为 1 了!

### 错误流程
```
北4局结束(非连庄)
↓
newRound = 5 (round + 1)
↓
newRound > 4 ✅
↓
newRound = 1  ← ⚠️ 先重置了!
newWind = 'north' (因为是最后一个风位,无法切换)
↓
checkGameOver({ wind: 'north', round: 1 })
↓
wind === 'north' ✅ && round > 4 ❌ (1 > 4 = false)
↓
游戏继续! 🐛
```

### 正确流程
```
北4局结束(非连庄)
↓
newRound = 5 (round + 1)
↓
newRound > 4 ✅
↓
先检查: checkGameOver({ wind: 'north', round: 5 })  ← ⚡ 关键!
↓
wind === 'north' ✅ && round > 4 ✅ (5 > 4 = true)
↓
isGameOver = true
↓
return (退出函数,不再重置 round)
↓
游戏结束! ✅
```

### 修复方法
在 `goToNextRound` 函数中,当 `newRound > 4` 时:
1. **先创建未重置的状态**: `{ wind: newWind, round: newRound }`
2. **先检查游戏是否结束**: `checkGameOver(players, nextStateBeforeReset)`
3. **如果结束**: 应用状态并 `return`
4. **如果未结束**: 才重置 `round = 1` 并切换风位

### 代码改动
- **修改文件**: `goToNextRound` 函数
- **新增代码**: 17行 (提前检查逻辑)
- **修改代码**: `checkGameOver` 函数注释优化
- **总计改动**: ~40行

### 影响范围
✅ **全庄战**: 修复了无法自动结束的 bug  
✅ **半庄战**: 依然正常工作  
✅ **东风战**: 依然正常工作  
✅ **连庄逻辑**: 不受影响  
✅ **飞满规则**: 不受影响

---

## ✅ 验证状态

- [x] 代码已修复
- [x] 逻辑已验证
- [x] 修复文档已完成
- [ ] 实际测试 (需要打16局全庄战)

### 建议测试步骤

1. 新建游戏,选择"全庄战"
2. 快速推进到北4局
   - 可以使用老手模式快速输入番符
   - 每局随意和牌,快速跳过
3. 北4局结束时(非连庄),观察是否自动显示最终结算界面
4. 验证历史记录是否正确记录为"北4局"
5. 验证游戏状态显示为"游戏结束"

### 测试检查点

| 检查项 | 预期结果 | 实际结果 |
|--------|---------|---------|
| 北4局结束后自动结算 | ✅ 显示结算界面 | 待测试 |
| 历史记录显示北4局 | ✅ 显示"北4局" | 待测试 |
| 游戏状态为结束 | ✅ isGameOver = true | 待测试 |
| 无法继续下一局 | ✅ 按钮隐藏或禁用 | 待测试 |

---

**修复人员**: GitHub Copilot  
**修复方法**: 调整检查时机 + 提前验证  
**修复状态**: ✅ 完成  
**测试状态**: 待实际测试  
**修复时间**: 2025年10月28日
